#include "TM4C123GH6PM.H"
int volatile count = 0;

//-----------------------Delay function------------------------------------
void Delay_ms(int n)
{
  int i, j;
  for(i = 0 ; i < n; i++)
  {}
   for(j = 0; j < 3180; j++)
    {}  /* excute for 1ms */
}
//------------------------------------------------------------------------
//----------------PWN for Glowing Blue LED--------------------------------
void PWM_for_LED_BLUE()
{
  
  PWM1->_3_CTL = 0;// Disable PWM generator
  PWM1->_3_GENA = 0x0000008C;// when count = comparator A (down counter) drive pwmA = low and make it high when counter = load
  PWM1->_3_LOAD = 32000;// set load value for 500Hz
  PWM1->_3_CMPA = 28799;// 90% of 32000, 10% duty cycle
  PWM1->_3_CTL = 1;// Enable PWM generator and use down counter
  PWM1->ENABLE |= (1U << 6); // Enable M1PWM6 generator 
  
}
//-----------------------------------------------------------------------
//---------------PWM for glowing Green LED-------------------------------
void PWM_for_LED_GREEN()
{
  PWM1->_3_CTL = 0;// Disable PWM generator
  PWM1->_3_GENB = 0x0000008C;// when count = comparator B (down counter) drive pwmB = low and make it high when counter = load
  PWM1->_3_LOAD = 1600;// set load value for 10kHz
  PWM1->_3_CMPA = 159;// 10% of 1600, 90% duty cycle
  PWM1->_3_CTL = 1;// Enable PWM generator and use down counter
  PWM1->ENABLE |= (1U << 7); // Enable M1PWM7 generator
}
//----------------------------------------------------------------------

void GPIOF_Handler(void);
//------------------------Main interrupt function----------------------
void BlinkLED(){
  // --------------------key debouncing exists--------------------------
  if(GPIOF->MIS & 0x01)
  {
    Delay_ms(250); //250ms delay
    if(count == 0)
    {
      PWM1->ENABLE = 0x0;// Disable PWM generator
      GPIOF->DATA = 0x0;// Turn off all LEDs
      GPIOF->DATA |= (1U << 1);// make LED RED glow
      count++;// Increment count
      GPIOF->ICR |= (1U << 0);// need for edge triggering
      return;// return to main function
      
    }
    else if (count == 1)
    {
      GPIOF->DATA = 0x0; // Turn off all LEDs
      PWM_for_LED_BLUE();// Generate PWN signal on Pin 2 of Port F
      count++;// Increment count
      GPIOF->ICR |= (1U << 0);// need for edge triggering
      return;// return to main function
    }
  
    else if(count == 2)
    {
      PWM1->ENABLE = 0x0;// Disable PWM generator
      GPIOF->DATA = 0x0;// Turn off all LEDs
      PWM_for_LED_GREEN();// Generate PWM signal on Pin 3 of Port F
      count = 0;// reset count
      GPIOF->ICR |= (1U << 0);// need for edge triggering
      return;// return to main fucntion
    }
  }
  else if(GPIOF->MIS & 0x10)
  {
    Delay_ms(250);// 250 delay
    PWM1->ENABLE = 0x0;// Disable PWM generator
    GPIOF->DATA = 0x0;// Turn off all LEDs
    GPIOF->ICR |= (1U << 4);// need for edge triggering
    count = 0;// reset count
    return;// return to main function
  }
}

void main()
{
  // Clock configuration//
  SYSCTL->RCGCPWM |= (1U << 1);// provide clock to PWM module 1
  SYSCTL->RCC &= ~(1U << 20);// no pre divider is used i.e 16 MHz clock is given to PWM module
  SYSCTL->RCGCGPIO |= (1U << 5);// enable clock at Port F
  
  
  //GPIO configuration//
  GPIOF-> LOCK = 0x4C4F434B;// Unlock port F configuration
  GPIOF->CR |= (1U << 0);//configure the special functins of port F
  GPIOF->AFSEL = (1U << 3) | (1U << 2); // Use alternative functions of Pin 2 and 3
  GPIOF->PCTL &= ~0x0000FF00; // mask PMC for pin 2 and 3
  GPIOF->PCTL |= 0x00005500; // Enable the 5th alternate function i.e PWM
  GPIOF->DIR &= ~(1U << 0) | ~(1U << 4); // make pin 0 and 4 as input
  GPIOF->DIR |= (1U << 1); // make pin 1 as output
  GPIOF->DEN |= (1U << 3) | (1U << 2) | (1U << 1) | (1U << 0) | (1U << 4);// make pin 0,1,2,3 as digital enable
  GPIOF->PUR |= (1U << 0) | (1U << 4);// pull up register on pin 0 and 4
  
  __disable_irq(); // disable interrupts before configuring them
  
  GPIOF->IS &= ~(1U << 0) | ~(1U << 4);// enable edge triggered interrupt on pin 0 and 4
  GPIOF->IM |= (1U << 0) | (1U << 4);// makes it so interrupt generated by pin 0 and 4is sent to interrupt controller // unmask pin 0 and 4
  GPIOF->IBE &= ~(1U << 0) | ~(1U << 4);// make it so it either detect rising or falling edges not both
  GPIOF->IEV |= (1U << 0) | (1U << 4); // detect rising edge
  GPIOF->ICR |= (1U << 0) | (1U << 4); // only needed for edge triggering purposes, needed to clear bit after interrupt has been generated and processed.
  
  GPIOF->LOCK = 0X0;// commit //  save changes and lock port F
  __enable_irq();// enable the interrupts
  
  NVIC->IP[30] = 3 << 5;// set priority to 3. I cannot find these 2 in datasheet// used another document APP (saved in ESD folder)
  NVIC->ISER[0] |= (1U << 30); // enable Port F as interrput (30 in ISER[0] bit) 
  
  while (1)
  {
    // wait for interrupt
    GPIOF_Handler();
  }
}

void GPIOF_Handler(void)
{// since ISR should be very short I'm just calling a function in this
  BlinkLED();
  
}